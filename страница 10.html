ч	<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Алгоритм Дейкстры.</title>
	<body bgcolor="#FFF" background="хаха.jpg">
	</body>
	<h1 style="color:#A52A2A"><center>Алгоритм Дейкстры.<div class=""></div></center></h1>
	<br>
	<h2>Алгоритм Дейкстры работает на ориентированных (с некоторыми дополнениями и на<br /> неориентированных) графах, и призван искать кратчайшие пути между заданной вершиной и<br /> всеми остальными вершинами в графе.</h2>
	<br />
	<h3>Как правило, граф обозначают как набор вершин и рёбер \inline G = (V,E), где число рёбер может<br /> быть задано \inline m, а вершин числом \inline n.</h3>
	<br />
	<h3>Для каждого ребра в графе задан неотрицательный вес \inline l_i, а также вершина, из которой<br /> осуществляется поиск оптимальных путей.</h3>
	<br />
	<h3>Алгоритм Дейкстры может найти кратчайший путь между вершинами \inline s и \inline t в графе, только если<br /> существует хотя бы один путь между этими вершинами. Если это условие не выполняется, то<br /> алгоритм отработает корректно, вернув значение "бесконечность" для пары несвязанных вершин.</h3>
	<br />
	<h3>Условие неотрицательности весов рёбер крайне важно и от него нельзя просто избавиться. Не<br /> получится свести задачу к решаемой алгоритмом Дейкстры, прибавив наибольший по модулю вес<br /> ко всем рёбрам. Это может изменить оптимальный маршрут. На рисунке видно, что в первом<br /> случае оптимальный путь между \inline a и \inline d (сумма рёбер на пути наименьшая) изменяется при такой<br /> манипуляции. В оригинале путь проходит через \inline a \rightarrow b \rightarrow c \rightarrow d, а после добавления семёрки к<br /> всем рёбрам, оптимальный путь проходит через \inline a \rightarrow c \rightarrow d.</h3>
	<center><img src="div20.png" width="600" height="300" alt=""></center>
	<p><center>рис.20</center></p>
	<br />
	<h3>Как ведёт себя алгоритм Дейкстры на исходном графе, мы разберём, когда выпишем алгоритм.<br /> Но для начала зададимся другим вопросом: "почему не применить поиск в ширину для нашего<br /> графа?". Известно, что метод BFS находит оптимальный путь от произвольной вершины в<br /> ориентированном графе до любой другой вершины, но это справедливо только для рёбер с<br /> единичным весом.</h3>
<br />
<h3>Свести задачу к решаемой BFS можно, но если заменить все рёбра неединичной длины<br /> \inline n рёбрами длины \inline 1, то граф очень разрастётся, и это приведёт к огромному числу действий при<br /> вычислении оптимального маршрута.</h3>
<h2>Чтобы этого избежать предлагается использовать алгоритм Дейкстры. Опишем его:</h2>
	<h1 style="color:#A52A2A">Инициализация:</h1>
	<h3>Задаём множество X = \{s\}, состоящее из исходной вершины.<br>
Массив длин кратчайших путей  	 A, в котором изначально есть 	 A[s] = 0, кратчайших путь от вершины до себя самой.</h3>
	<h1 style="color:#A52A2A">Основный цикл алгоритма::</h1	>
	<h3>Пока все вершины не исследованы (или формально  X  V), повторяем:<br>
Среди всех рёбер в графе  (v,w) таких, что  v  X, а   X, выбираем одно, которое минимизирует<br> сумму:  A[v] + l_{vw}.
Добавяем эту вершину  w в X.<br>
Задаём  A[w] равным  A[v] + l_\{vw\}.</h3>
<br>
<h2>В итоге исполнения этого алгоритма, массив  A будет содержать все оптимальные пути, исходящие из  s.</h2>
<br>
	<h1 style="color:#A52A2A">Примеры работы</h1>
	<br>
		<center><img src="vid21.png" width="600" height="300" alt=""></center>
	<p><center>рис.21</center></p>
	<br />
	<h2>Рассмотрим граф выше, в нём будем искать пути от  a до всего остального.</h2>
	<br>
	<h3>Первый шаг алгоритма определит, что кратчайший путь до  b проходит по направлению синей стрелки<br> и зафиксирует кратчайший путь. Второй шаг рассмотрит, все возможные варианты  A[v] + l_{vw} и<br> окажется, что оптимальный вариант двигаться вдоль красной стрелки, поскольку  5 меньше, чем<br> \inline 3 + 3 = 6 и  3 + 6 = 9. Добавляется длина кратчайшего пути до c. И наконец, третьим шагом, когда<br>	 три вершины  a,b,c уже лежат в  X, остается рассмотреть только два ребра и выбрать, лежащее<br> вдоль зеленой стрелки.

</h3>
<br>
<h3>
Теперь рассмотрим граф с отрицательными весами, упомянутый выше. Напомню, алгоритм<br> Дейкстры на таком графе может работать некорректно.</h3>
		<center><img src="vid22.png" width="600" height="300" alt=""></center>
	<p><center>рис.22</center></p>
	<br />
	<h3>Первым шагом отбирается ребро вдоль синей стрелки, поскольку это ребро наименьшего веса из<br> исходной вершины. Затем выбирается ребро  c  d. Это зафиксирует навсегда неверный путь от  a к<br>  d, в то время как оптимальный путь проходит через центр с отрицательным весом. Последним<br> шагом, будет добавлена вершина 	 b.

</h3>
  <h2><center>страница 10</center></h2>
 <head>
  <meta charset="utf-8">
  <title>Кнопка</title>
  <style>
   .btn {
    display: inline-block; /* Строчно-блочный элемент */
    background: #8C959D; /* Серый цвет фона */
    color: #fff; /* Белый цвет текста */
    padding: 1rem 1.5rem; /* Поля вокруг текста */
    text-decoration: none; /* Убираем подчёркивание */
    border-radius: 3px; /* Скругляем уголки */
   }
  </style>
 </head>
 <body><button style=" margin: 0 auto;
   display: block;">
	<a href="страница 9.html" class="btn">страница 9</a>

	<head>
		<meta charset="utf-8">
		<title>Кнопка</title>
		<style>
			.btn {
				display: inline-block; /* Строчно-блочный элемент */
				background: #8C959D; /* Серый цвет фона */
				color: #fff; /* Белый цвет текста */
				padding: 1rem 1.5rem; /* Поля вокруг текста */
				text-decoration: none; /* Убираем подчёркивание */
				border-radius: 3px; /* Скругляем уголки */
			}
		</style>
	</head>
	<a href="index.html" class="btn">главная</a>
</body>
</html>
</body>








